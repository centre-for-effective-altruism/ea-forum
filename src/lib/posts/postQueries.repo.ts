/* Generated by tradukisto - do not edit manually */

import type { PostgresClient } from "tradukisto";
import type {
  IFrontpagePostsList,
  IFrontpagePostsListParams,
  ISidebarOpportunities,
  ISidebarOpportunitiesParams,
  ISidebarEvents,
  ISidebarEventsParams,
  IPostById,
  IPostByIdParams,
  IPostBodyById,
  IPostBodyByIdParams,
} from "./postQueries.schemas.ts";

export const frontpagePostsListSql = `-- Posts.frontpagePostsList
SELECT "p"."_id", "p"."slug", "p"."title", "p"."baseScore", "p"."voteCount", "p"."commentCount", "p"."postedAt", "p"."curatedDate", "p"."isEvent", "p"."groupId", "p"."sticky", "p"."eventImageId", "p"."socialPreview", "p"."socialPreviewImageAutoUrl", "p"."readTimeMinutesOverride", "contents"."wordCount", SUBSTRING("contents"."html", 1, 200) AS "htmlHighlight", JSON_BUILD_OBJECT('_id', "u"."_id", 'slug', "u"."slug", 'displayName', "u"."displayName", 'createdAt', "u"."createdAt", 'profileImageId', "u"."profileImageId", 'karma', "u"."karma", 'jobTitle', "u"."jobTitle", 'organization', "u"."organization", 'postCount', "u"."postCount", 'commentCount', "u"."commentCount", 'biography', ("u"."biography" ->> 'html')::TEXT) AS "user", ARRAY_AGG(JSON_BUILD_OBJECT('_id', "coauthor"."_id", 'slug', "coauthor"."slug", 'displayName', "coauthor"."displayName", 'createdAt', "coauthor"."createdAt", 'profileImageId', "coauthor"."profileImageId", 'karma', "coauthor"."karma", 'jobTitle', "coauthor"."jobTitle", 'organization', "coauthor"."organization", 'postCount', "coauthor"."postCount", 'commentCount', "coauthor"."commentCount", 'biography', ("coauthor"."biography" ->> 'html')::TEXT)) AS "coauthors", ARRAY_AGG(JSON_BUILD_OBJECT('_id', "tag"."_id", 'name', "tag"."name", 'slug', "tag"."slug", 'core', "tag"."core")) AS "tags" FROM "Posts" AS "p" LEFT JOIN "Revisions" AS "contents" ON "p"."contents_latest" = "contents"."_id" LEFT JOIN "Users" AS "u" ON "p"."userId" = "u"."_id" AND NOT "u"."deleted" LEFT JOIN "Users" AS "coauthor" ON "coauthor"."_id" = ANY("p"."coauthorUserIds") AND NOT "coauthor"."deleted" LEFT JOIN "Tags" AS "tag" ON ("p"."tagRelevance" -> "tag"."_id")::INTEGER >= 1 AND NOT "tag"."deleted" WHERE NOT "p"."draft" AND NOT "p"."deletedDraft" AND NOT "p"."isFuture" AND NOT "p"."unlisted" AND NOT "p"."shortform" AND NOT "p"."rejected" AND NOT "p"."authorIsUnreviewed" AND NOT "p"."hiddenRelatedQuestion" AND "p"."postedAt" IS NOT NULL AND "p"."status" = 2 AND NOT "p"."isEvent" AND NOT "p"."sticky" AND "p"."groupId" IS NULL AND "p"."frontpageDate" > TO_TIMESTAMP(0) AND "p"."postedAt" > NOW() - MAKE_INTERVAL(days => COALESCE($1::INTEGER, 21)) GROUP BY "p"."_id", "contents"."_id", "u"."_id" ORDER BY "p"."sticky" DESC, "p"."stickyPriority" DESC, ("p"."baseScore" + (CASE WHEN "p"."frontpageDate" IS NOT NULL THEN 10 ELSE 0 END) + (CASE WHEN "p"."curatedDate" IS NOT NULL THEN 10 ELSE 0 END)) / POW(EXTRACT(EPOCH FROM NOW() - "p"."postedAt") / 3600000 + COALESCE($2::DOUBLE PRECISION, 2), COALESCE($3::DOUBLE PRECISION, 0.8)) DESC, "p"."_id" DESC LIMIT $4`;

export const sidebarOpportunitiesSql = `-- Posts.sidebarOpportunities
SELECT "_id", "slug", "title", "postedAt", "isEvent", "groupId" FROM "Posts" WHERE NOT "Posts"."draft" AND NOT "Posts"."deletedDraft" AND NOT "Posts"."isFuture" AND NOT "Posts"."unlisted" AND NOT "Posts"."shortform" AND NOT "Posts"."rejected" AND NOT "Posts"."authorIsUnreviewed" AND NOT "Posts"."hiddenRelatedQuestion" AND "Posts"."postedAt" IS NOT NULL AND "Posts"."status" = 2 AND NOT "isEvent" AND NOT "sticky" AND "groupId" IS NULL AND "frontpageDate" > TO_TIMESTAMP(0) AND "postedAt" > NOW() - MAKE_INTERVAL(days => COALESCE($1::INTEGER, 21)) AND ("tagRelevance" -> 'z8qFsGt5iXyZiLbjN')::INTEGER >= 1 ORDER BY "Posts"."sticky" DESC, "Posts"."stickyPriority" DESC, ("Posts"."baseScore" + (CASE WHEN "Posts"."frontpageDate" IS NOT NULL THEN 10 ELSE 0 END) + (CASE WHEN "Posts"."curatedDate" IS NOT NULL THEN 10 ELSE 0 END)) / POW(EXTRACT(EPOCH FROM NOW() - "Posts"."postedAt") / 3600000 + COALESCE($2::DOUBLE PRECISION, 2), COALESCE($3::DOUBLE PRECISION, 0.8)) DESC, "Posts"."_id" DESC LIMIT $4`;

export const sidebarEventsSql = `-- Posts.sidebarEvents
SELECT "_id", "slug", "title", "startTime", "onlineEvent", "googleLocation", "isEvent", "groupId" FROM "Posts" WHERE NOT "Posts"."draft" AND NOT "Posts"."deletedDraft" AND NOT "Posts"."isFuture" AND NOT "Posts"."unlisted" AND NOT "Posts"."shortform" AND NOT "Posts"."rejected" AND NOT "Posts"."authorIsUnreviewed" AND NOT "Posts"."hiddenRelatedQuestion" AND "Posts"."postedAt" IS NOT NULL AND "Posts"."status" = 2 AND "isEvent" AND "startTime" > NOW() ORDER BY "startTime" ASC, "baseScore" DESC, "_id" DESC LIMIT $1`;

export const postByIdSql = `-- Posts.postById
SELECT "p"."_id", "p"."title", "p"."slug", "p"."isEvent", "p"."groupId", "p"."eventImageId", "p"."socialPreview", "p"."socialPreviewImageAutoUrl", "p"."readTimeMinutesOverride", "p"."postedAt", "p"."baseScore", "p"."commentCount", "contents"."wordCount", SUBSTRING("contents"."html", 1, 200) AS "htmlHighlight", JSON_BUILD_OBJECT('_id', "u"."_id", 'slug', "u"."slug", 'displayName', "u"."displayName", 'createdAt', "u"."createdAt", 'profileImageId', "u"."profileImageId", 'karma', "u"."karma", 'jobTitle', "u"."jobTitle", 'organization', "u"."organization", 'postCount', "u"."postCount", 'commentCount', "u"."commentCount", 'biography', ("u"."biography" ->> 'html')::TEXT) AS "user", ARRAY_AGG(JSON_BUILD_OBJECT('_id', "coauthor"."_id", 'slug', "coauthor"."slug", 'displayName', "coauthor"."displayName", 'createdAt', "coauthor"."createdAt", 'profileImageId', "coauthor"."profileImageId", 'karma', "coauthor"."karma", 'jobTitle', "coauthor"."jobTitle", 'organization', "coauthor"."organization", 'postCount', "coauthor"."postCount", 'commentCount', "coauthor"."commentCount", 'biography', ("coauthor"."biography" ->> 'html')::TEXT)) AS "coauthors", ARRAY_AGG(JSON_BUILD_OBJECT('_id', "tag"."_id", 'name', "tag"."name", 'slug', "tag"."slug", 'core', "tag"."core")) AS "tags" FROM "Posts" AS "p" LEFT JOIN "Revisions" AS "contents" ON "p"."contents_latest" = "contents"."_id" LEFT JOIN "Users" AS "u" ON "p"."userId" = "u"."_id" AND NOT "u"."deleted" LEFT JOIN "Users" AS "coauthor" ON "coauthor"."_id" = ANY("p"."coauthorUserIds") AND NOT "coauthor"."deleted" LEFT JOIN "Tags" AS "tag" ON ("p"."tagRelevance" -> "tag"."_id")::INTEGER >= 1 AND NOT "tag"."deleted" WHERE "p"."_id" = $1::TEXT AND (NOT "p"."draft" AND NOT "p"."deletedDraft" AND NOT "p"."isFuture" AND NOT "p"."unlisted" AND NOT "p"."shortform" AND NOT "p"."rejected" AND NOT "p"."authorIsUnreviewed" AND NOT "p"."hiddenRelatedQuestion" AND "p"."postedAt" IS NOT NULL AND "p"."status" = 2 OR ($2::TEXT IS NOT NULL AND ($2::TEXT = "p"."userId" OR $2::TEXT = ANY("p"."coauthorUserIds"))) OR COALESCE($3::BOOLEAN, FALSE)) GROUP BY "p"."_id", "contents"."_id", "u"."_id" LIMIT 1`;

export const postBodyByIdSql = `-- Posts.postBodyById
SELECT "p"."_id", "contents"."html" AS "body" FROM "Posts" AS "p" LEFT JOIN "Revisions" AS "contents" ON "p"."contents_latest" = "contents"."_id" WHERE "p"."_id" = $1::TEXT AND (NOT "p"."draft" AND NOT "p"."deletedDraft" AND NOT "p"."isFuture" AND NOT "p"."unlisted" AND NOT "p"."shortform" AND NOT "p"."rejected" AND NOT "p"."authorIsUnreviewed" AND NOT "p"."hiddenRelatedQuestion" AND "p"."postedAt" IS NOT NULL AND "p"."status" = 2 OR ($2::TEXT IS NOT NULL AND ($2::TEXT = "p"."userId" OR $2::TEXT = ANY("p"."coauthorUserIds"))) OR COALESCE($3::BOOLEAN, FALSE)) GROUP BY "p"."_id", "contents"."_id" LIMIT 1`;

export class PostsRepo {
  protected client: PostgresClient;

  constructor(client: PostgresClient) {
    this.client = client;
  }

  async frontpagePostsList(
    params: IFrontpagePostsListParams,
  ): Promise<IFrontpagePostsList[]> {
    const res: IFrontpagePostsList[] = await this.client.fetchRows(
      frontpagePostsListSql,
      [
        params.cutoffDays === undefined ? null : params.cutoffDays,
        params.scoreBias === undefined ? null : params.scoreBias,
        params.timeDecayFactor === undefined ? null : params.timeDecayFactor,
        params.limit === undefined ? null : params.limit,
      ],
    );
    return res;
  }

  async sidebarOpportunities(
    params: ISidebarOpportunitiesParams,
  ): Promise<ISidebarOpportunities[]> {
    const res: ISidebarOpportunities[] = await this.client.fetchRows(
      sidebarOpportunitiesSql,
      [
        params.cutoffDays === undefined ? null : params.cutoffDays,
        params.scoreBias === undefined ? null : params.scoreBias,
        params.timeDecayFactor === undefined ? null : params.timeDecayFactor,
        params.limit === undefined ? null : params.limit,
      ],
    );
    return res;
  }

  async sidebarEvents(params: ISidebarEventsParams): Promise<ISidebarEvents[]> {
    const res: ISidebarEvents[] = await this.client.fetchRows(sidebarEventsSql, [
      params.limit === undefined ? null : params.limit,
    ]);
    return res;
  }

  async postById(params: IPostByIdParams): Promise<IPostById | null> {
    const res: IPostById[] = await this.client.fetchRows(postByIdSql, [
      params.postId === undefined ? null : params.postId,
      params.currentUserId === undefined ? null : params.currentUserId,
      params.currentUserIsAdmin === undefined ? null : params.currentUserIsAdmin,
    ]);
    return res?.[0] ?? null;
  }

  async postBodyById(params: IPostBodyByIdParams): Promise<IPostBodyById | null> {
    const res: IPostBodyById[] = await this.client.fetchRows(postBodyByIdSql, [
      params.postId === undefined ? null : params.postId,
      params.currentUserId === undefined ? null : params.currentUserId,
      params.currentUserIsAdmin === undefined ? null : params.currentUserIsAdmin,
    ]);
    return res?.[0] ?? null;
  }
}
